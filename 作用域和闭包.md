# js的作用域链

## 作用域

对于javascript,它也有一个`编译`过程,只是这个过程发生在代码执行前的几微秒,而不是和其它语言一样发生在构建之前.所以js中也会两个过程

*   编译
*   执行

当然要了解作用域我们还需要知道三个东西

*   引擎(执行代码)
*   编译器(负责语法分析及代码生成)
*   作用域(负责收集并维护所有的声明的标识符(变量)组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限))

比如:

```javascript
var a = 2;
```

编译器则会进行如下处理

1. 遇到var a,编译器会访问作用域是否有一个该名称的变量存在同一个作用域的集合中.如果是,编译器会忽略该声明,继续进行编译.否则会要求作用域在当前作用域集合中声明一个新变量,并命名为a
2. 接下来编译器为引擎生成运行时所需要的代码,这些代码用来处理a=2这个赋值操.引擎运行时会首先询问作用域,在当前作用域中集合中是否存在一个叫作a的变量.如果是,引擎就会使用这个变量,把2赋值给它.否则会继续向上级作用域查找

## LHS和RHS

LHS(左查询)和RHS(非左查询)是发生在代码执行阶段,简单的说,LHS是赋值操作的时候运行,而RHS是取值时候运行

但是程序在处理这两种查询的时候是不一样的

```javascript
function foo(a) {
console.log( a + b );
b = a;
}
foo( 2 );
```

在执行`foo`的时候,第一次`b`是没有定义的,这个时候进行RHS查询,找遍所有的作用域都找不到这个变量,引擎就会抛出`ReferenceError`的异常.但是对于LHS查询的时候,它是一个赋值的操作,引擎会默认在全局作用域下创建一个变量,并返还给引擎,但是这只是在`非严格模式下`,`严格模式`下和RHS是一样的

## 词法作用域

编译器的第一个工作阶段就叫词法化,词法作用域就是在这个过程中出现的(编译过程完成)

词法作用域就是定义词法阶段的作用域,也就是说词法作用域就是你写代码的时将变量和块作用域写在哪里决定的,因此词法处理器在处理代码时候会保持作用于不变(这个非常重要,排除eval和with的影响)

```javascript
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log( a, b, c );
    }
    bar( b * 3 );
}
foo( 2 ); // 2, 4, 12
```

因为作用域是嵌套的,所以上面三个会生成三级作用域气泡

![](./asserts/01.png)

所以在代码执行阶段,作用域气泡的结构和互相之间的位置关系就给引擎提供了足够的信息.引擎用这些信息去查找标识符的位置

### 词法作用域查找

上面代码中`console.log(a,b,c)`中会进行a,b,c三个RHS查找,当然他们会在当前作用域中查找,然后依次往上级作用域查找(只能往上,不能往下),知道找到第一个目标标识符的时候停止查找

前面我们说过词法作用是由代码写在哪里决定的,并且会一直保持不变(因为这个过程是在编译完成的).而代码执行是在引擎的执行阶段完成的,所以这个时候无论你的函数在哪里调用,它的词法作用于都是保持不变的(这也就是闭包生效的基础)

### 函数作用域和块级作用域

之前我们说到作用域气泡,就是一个大气泡里面嵌套小气泡,也就是嵌套作用域,大气泡也就是全局作用域,小气泡就是局部作用域

函数和代码块都会生成新的`作用域气泡`,对于`局部作用域`会起到`遮蔽效应`,就是在外层不可以访问到内层作用域变量

到这里我们知道任何声明在某个作用域内的变量,都将依赋于这个作用域

### 声明提升

```javascript
console.log( a );//undefined
var a;
a = 2;
```

如果代码是从上面往下一行行执行的话,上面代码应该会出现`ReferenceError:`的错误,但是却是`undefined`,说明在作用域定义了变量`a`.这里就是变量声明提升

首先`作用域`是在编译阶段生成的,也就是说,在引擎执行代码之前,会用编译器先编译代码,找到代码中所有的声明,并用合适的作用域将他们关联起来.这样的话,变量和函数的声明会在编译阶段就会被提升到当前作用域的最前面,也就是在在任何代码被执行之前.对于赋值是出现在代码的运行阶段,所以赋值操作会留在原地,并没有提升的过程.这样就可以解释上面出现的结果.

但是我们必须强调变量提升只是针对当前作用域,是不可能出现跨作用域的提升,同时每个作用域都会提升操作

需要注意一点:

```javascript
foo(); // 1
var foo;
function foo() {
    console.log( 1 );
}
```

就是函数的声明是优先于变量的,如果同时多个函数重名的声明,后面的会覆盖前面的

## 闭包

前面我们提到了词法作用域,闭包也就是基于词法作用域产生的.其实我们代码中有很多闭包,只是我们不知道,不能根据自己意愿去识别.

那什么是闭包?看定义,就是当函数可以记住并访问所在的的词法作用域时,就生成了闭包,即使函数在当前词法作用域之外执行(之前就提到过词法作用域一旦形成是不会变).

另外一种说法就是一个闭包就是能够读取其他函数内部变量的函数(这样理解也是闭包)

所以我总结两点(有意义的闭包)

*   能够记住所在的词法作用域
*   在词法作用域之外执行

我们看下面代码

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log( a ); // 2
    }
    bar();
}
foo();
```

那上面是闭包吗?

技术上来说,是闭包,但是根据定义又不是,它只是利用了词法作用域的查找规则,而这些规则只是闭包的一部分

从技术上说,bar()具有一个涵盖foo()作用域的闭包(其实是涵盖了它能访问的所有作用域),也可以认为bar()被封闭在了foo()的作用域内,因为bar()嵌套在foo()内部

看下面代码

```javascript
function foo() {
    var a = 2;
    function bar() {
        console.log( a );
    }
    return bar;
}
var baz = foo();
baz(); // 2,这才是闭包
```

从上面我们可以看到,foo执行的时候,把函数bar作为一个值返回,所以在baz执行的时候,函数bar在其词法作用域之外执行了,同时bar保持着对该作用域的引用,而该引用就是闭包(bar函数),所以该作用域不会被垃圾回收给回收,会一直保存

### 其他形式的闭包

还有地方我们会用到闭包,比如

**1.在函数内部绑定的事件回调函数**

```javascript
function setupBot(name, selector) {
    $( selector ).click( function activator() {
        console.log( "Activating: " + name );
    } );
}
```

**2.自执行函数**

```javascript
var a = 2;
(function IIFE() {
    console.log( a );
})();
```

因为自执行函数有一个独立的块级作用域,但是可访问到全局作用域,但是严格来说因为没有在作用域之外执行,所以这里讨论闭包也就是没有什么意义,a只是通过词法作用域的查找规格访问到

### 循环中的闭包

```javascript
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );
    }, i*1000 );
}
```

预期本身是想输出的是1~5,但是结果却是5个6,6来自循环结束时候的i就是等于6,所以输出的都是循环结束的i.为什么会出现这种情况?

这种原因是很简单的,首先因为延迟函数的回调会加入事件队列中,只有当循环结束的时候才会去执行,同时因为i并没有独立保存,最终是共享作用域中的i,此时i已经是6.所以最终输入的都是6

所以我们要想获得1~5的话也是非常简单的,就是我们需要一个独立的作用域

```javascript
for (var i=1; i<=5; i++) {
    (function() {
        setTimeout( function timer() {
            console.log( i );
        }, i*1000 );
    })();
}
```

不过,当你运行这个循环的时候,虽然是有独立的作用域,每次循环的都会创建一个独立的作用域,但是这个作用域内是空的,依赖会到全局是拿i,此时也还是得到5个6

所以我们需要把i传到这个独立作用域中去,然后保存

```javascript
for (var i=1; i<=5; i++) {
    (function(j) {
        //var j = i
        setTimeout( function timer() {
            console.log( j );
        }, i*1000 );
    })(i);
}
```

除了用自执行函数,在es6中增加了`let`关键字,let声明的变量可以挟持块作用域,并且在这个块级作用中声明一个变量(其实就是把一个块级转换成了封闭的作用域),因为fo循环中的let在循环中每次循环都会重新声明一次,并且随后每次迭代都会用上次迭代结束时候的值来初始化这个变量.这就是为什么let可以得到我们之前用自执行函数同样的效果(本质还是创建了独立的作用域)

```javascript
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log(i);
    }, i*1000 );
}
```

当然闭包的时候很在程度上是隐藏作用域,并且能够在词法作用域之外.但是现如今的模块机制就很好的实现了这点

## 动态作用域

作用域模型

*   动态作用域
*   词法作用域

之前我们已经讨论过词法作用域是一套关于引擎如何寻找变量以及找到变量的规则.同时词法作用域也是发生在词法化阶段(编译阶段)

动态作用域确实让作用域作为一个在运行时确定的形式,而不是在写代码时候进行静态确定的.看下面代码

```javascript
function foo() {
    console.log( a ); // 2
}
function bar() {
    var a = 3;
    foo();
}
var a = 2;
bar();
```

如果是词法作用域的话,a会进行RHS查询,所以结果是2.但是如果要是动态作用域的话,它不关心函数和作用域是在哪里被声明的,只关心从何处调用,作用域链式基于调用栈的,而不是代码的作用域嵌套,这样的话输出结果就是3

不过要强调一点,javascript中不具有动态作用域,但是为什么我们要说到动态作用域呢?因为`this`机制就和动态作用域有点像

再次强调一下,`this`不是的作用域是运行时确定的,所以this的关注点就是函数在哪里调用了,和写在哪里一毛钱关系都没有,所以要非常非常注意这点(不过也有个特例,就是es6中的`箭头函数`)








